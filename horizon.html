<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Acid Waves — Psychedelic Ripples</title>
<style>
  :root {
    --base-cyan: #00ffff; /* requested bright cyan base */
    --bg: #001015;        /* very dark teal to make neon pop */
  }
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;            /* no scrolling */
    background: var(--bg);
    touch-action: none;          /* allow custom multi-touch gestures */
    -webkit-tap-highlight-color: transparent;
    color: white;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }

  /* Fullscreen canvas */
  #gl {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    display: block;
  }

  /* Minimal UI overlay for credits/instructions (non-intrusive) */
  .hud {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0.75rem;
    display: flex;
    justify-content: center;
    pointer-events: none; /* let touches hit canvas */
  }
  .pill {
    background: color-mix(in oklab, var(--base-cyan) 35%, #000);
    border: 1px solid rgba(255,255,255,0.25);
    color: #eaffff;
    padding: 0.5rem 0.75rem;
    border-radius: 999px;
    font-size: 0.85rem;
    letter-spacing: 0.02em;
    text-shadow: 0 1px 6px rgba(0, 255, 255, 0.6);
    backdrop-filter: blur(8px) saturate(140%);
    box-shadow:
      0 0 25px rgba(0,255,255,0.25),
      inset 0 0 22px rgba(0,255,255,0.1);
  }
</style>
</head>
<body>
<canvas id="gl"></canvas>
<div class="hud"><div class="pill">Touch / click & drag to make neon ripples</div></div>

<script>
/*
  Acid Waves — Single-file, mobile-first WebGL psychedelic ripple field
  - Fullscreen canvas, no scrolling
  - Multi-touch + mouse
  - Time-based animation, wave decay with easing
  - Neon spectrum with liquid distortion + subtle noise
*/

// Config
const MAX_WAVES = 16;   // simultaneous wave sources
const DECAY = 1.25;     // seconds to decay influence (base)
const DECAY_VARIANCE = 0.6; // randomize per wave
const DPR_CAP = 2;      // cap devicePixelRatio for perf
const BASE_CYAN = [0.0, 1.0, 1.0]; // #00FFFF

// Boilerplate WebGL
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl', { antialias: false, depth: false, stencil: false, alpha: false, premultipliedAlpha: false });
if (!gl) {
  alert('WebGL not supported on this device/browser.');
}

// Vertex shader (full-screen triangle)
const vertSrc = `
attribute vec2 a_pos;
void main() {
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

// Fragment shader: neon liquid distortion + multi-sourced ripples
// Notes:
// - uv in [0,1] with aspect correction
// - waves: positions (xy), age (z), decay (w)
// - Noise and curl-like flow to add organic motion
const fragSrc = `
precision highp float;

uniform vec2 u_res;
uniform float u_time;
uniform vec4 u_waves[` + MAX_WAVES + `]; // x,y=pos (0..1), z=age, w=decay
uniform vec3 u_base; // base neon cyan

// Hash/Noise helpers
float hash(vec2 p) {
  p = fract(p * vec2(123.34, 456.21));
  p += dot(p, p + 45.32);
  return fract(p.x * p.y);
}
float noise(in vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  float a = hash(i);
  float b = hash(i + vec2(1.0, 0.0));
  float c = hash(i + vec2(0.0, 1.0));
  float d = hash(i + vec2(1.0, 1.0));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Smooth pulse for ripples (easing)
float smoothExp(float x) {
  x = clamp(x, 0.0, 1.0);
  // gentle ease-out curve
  return pow(1.0 - x, 2.5);
}

// Neon palette based on time and uv
vec3 neonPalette(float t) {
  // Cycle through bright neon hues
  float r = 0.6 + 0.5*sin(t*1.7 + 0.0);
  float g = 0.6 + 0.5*sin(t*1.9 + 2.1);
  float b = 0.6 + 0.5*sin(t*2.3 + 4.2);
  vec3 neon = vec3(r, g, b);
  neon = pow(neon, vec3(1.2)); // boost brights
  return clamp(neon, 0.0, 1.0);
}

// Domain warp utility
vec2 warp(vec2 uv, float t) {
  float n1 = noise(uv*2.0 + t*0.1);
  float n2 = noise(uv*3.7 - t*0.07);
  vec2 off = vec2(n1 - 0.5, n2 - 0.5);
  return uv + off * 0.06;
}

void main() {
  vec2 res = u_res;
  vec2 uv = gl_FragCoord.xy / res.xy;
  // Keep square-ish scale and center
  float asp = res.x / max(res.y, 1.0);
  vec2 cuv = (uv - 0.5);
  cuv.x *= asp;
  vec2 baseUV = cuv + 0.5;

  // Animate flow field
  float t = u_time;
  vec2 wuv = warp(baseUV, t);

  // Ripple accumulation: displacement + color phase
  vec2 disp = vec2(0.0);
  float phase = 0.0;
  float amp = 0.0;

  for (int i = 0; i < ` + MAX_WAVES + `; i++) {
    vec4 w = u_waves[i]; // w.xy=pos, w.z=age, w.w=decayDur
    if (w.w <= 0.0) continue; // inactive

    float age = w.z;
    float life = clamp(age / w.w, 0.0, 1.0);
    float e = smoothExp(life);

    // Distance in UV space (with aspect correction)
    vec2 p = w.xy;
    vec2 d = (baseUV - p);
    d.x *= asp;

    float r = length(d) + 1e-5;
    // Wavefront speed + frequency
    float speed = 0.65;
    float freq = 28.0;
    float k = r*freq - age*freq*speed;

    // Ripple: decaying sinus with inverse falloff
    float ripple = sin(k) * e / (1.0 + 24.0*r);

    // Add displacement along gradient and tangential to create swirl
    vec2 dir = normalize(d);
    vec2 tang = vec2(-dir.y, dir.x);
    disp += dir * ripple * 0.035;
    disp += tang * ripple * 0.015;

    // Color phase from ripple
    phase += ripple * 2.2;
    amp += e * 0.8;
  }

  // Apply displacement (second warp for liquid feel)
  vec2 uv2 = warp(baseUV + disp, t*1.1);

  // Subtle noise-based shimmer
  float grain = noise(uv2*vec2(320.0, 280.0) + t*0.7) * 0.05;

  // Neon gradient mix
  vec3 neon = neonPalette(t*0.55 + phase*0.25);
  // Blend towards base cyan for cohesive look
  vec3 base = u_base;
  vec3 color = mix(base, neon, clamp(0.35 + amp*0.65, 0.0, 1.0));

  // Additional hue shift using UV curvature
  float hueShift = sin((uv2.x+uv2.y)*8.0 + t*0.9 + phase)*0.25 + 0.25;
  color = mix(color, neonPalette(t*0.8 + hueShift*6.2831), 0.45);

  // Glow-style boost
  float glow = smoothstep(0.75, 1.0, max(color.r, max(color.g, color.b)));
  color += glow * 0.12;

  // Add grain as subtle variation
  color += grain;

  // Final tone map-ish soft clamp
  color = 1.0 - exp(-color * 1.25);

  gl_FragColor = vec4(color, 1.0);
}
`;

// Compile helpers
function makeShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile failed');
  }
  return s;
}
function makeProgram(vsSrc, fsSrc) {
  const vs = makeShader(gl.VERTEX_SHADER, vsSrc);
  const fs = makeShader(gl.FRAGMENT_SHADER, fsSrc);
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(p));
    throw new Error('Program link failed');
  }
  return p;
}

const prog = makeProgram(vertSrc, fragSrc);
gl.useProgram(prog);

// Fullscreen triangle buffer
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,  3, -1,  -1, 3
]), gl.STATIC_DRAW);
const a_pos = gl.getAttribLocation(prog, 'a_pos');
gl.enableVertexAttribArray(a_pos);
gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

// Uniform locations
const u_res = gl.getUniformLocation(prog, 'u_res');
const u_time = gl.getUniformLocation(prog, 'u_time');
const u_waves = gl.getUniformLocation(prog, 'u_waves[0]');
const u_base = gl.getUniformLocation(prog, 'u_base');

// State for waves
const waves = new Float32Array(MAX_WAVES * 4); // x,y,age,decay
const active = new Array(MAX_WAVES).fill(false);
const startTimes = new Float32Array(MAX_WAVES);
const decayDur = new Float32Array(MAX_WAVES);

// Time
let startTime = performance.now();

// Resize
function resize() {
  const dpr = Math.min(window.devicePixelRatio || 1, DPR_CAP);
  const w = Math.floor(innerWidth * dpr);
  const h = Math.floor(innerHeight * dpr);
  canvas.width = w;
  canvas.height = h;
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  gl.viewport(0, 0, w, h);
}
addEventListener('resize', resize, { passive: true });
resize();

// Utilities
function getUV(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) / rect.width;
  const y = (clientY - rect.top) / rect.height;
  return [x, 1 - y]; // flip Y for more intuitive feel
}

function spawnWave(x, y, speedScale=1) {
  // Reuse oldest or first inactive
  let idx = -1;
  let oldestAge = -1;
  const now = performance.now();
  for (let i = 0; i < MAX_WAVES; i++) {
    if (!active[i]) { idx = i; break; }
    // find one closest to done
    const age = (now - startTimes[i]) / 1000;
    const life = decayDur[i] > 0 ? age / decayDur[i] : 1;
    if (life > oldestAge) { oldestAge = life; idx = i; }
  }
  const variance = DECAY + (Math.random()*2-1)*DECAY_VARIANCE;
  const dur = Math.max(0.6, variance) / speedScale;

  active[idx] = true;
  startTimes[idx] = now;
  decayDur[idx] = dur;

  const base = idx*4;
  waves[base+0] = x;
  waves[base+1] = y;
  waves[base+2] = 0;     // age
  waves[base+3] = dur;   // decay
}

function updateWaves(tSec) {
  for (let i = 0; i < MAX_WAVES; i++) {
    if (!active[i]) continue;
    const base = i*4;
    const age = tSec - (startTimes[i] - startTimeMs)/1000;
    waves[base+2] = age;
    if (age > waves[base+3]) {
      active[i] = false;
      waves[base+3] = 0; // mark inactive
    }
  }
}

// Input handling: multi-touch + mouse
let isMouseDown = false;
let lastMouse = null;
let startTimeMs = startTime;

function handleTouch(e) {
  e.preventDefault();
  const type = e.type;
  const touches = e.touches;
  if (type === 'touchstart' || type === 'touchmove') {
    for (let i = 0; i < touches.length; i++) {
      const t = touches[i];
      const [u, v] = getUV(t.clientX, t.clientY);
      spawnWave(u, v, type === 'touchmove' ? 1.2 : 1.0);
    }
  }
}
function handleMouseDown(e) {
  isMouseDown = true;
  const [u, v] = getUV(e.clientX, e.clientY);
  spawnWave(u, v, 1.0);
  lastMouse = [u, v];
}
function handleMouseMove(e) {
  if (!isMouseDown) return;
  const [u, v] = getUV(e.clientX, e.clientY);
  // Spawn along drag path
  spawnWave(u, v, 1.25);
  lastMouse = [u, v];
}
function handleMouseUp() {
  isMouseDown = false;
}

canvas.addEventListener('touchstart', handleTouch, { passive: false });
canvas.addEventListener('touchmove', handleTouch, { passive: false });
canvas.addEventListener('touchend', (e)=>e.preventDefault(), { passive: false });
canvas.addEventListener('touchcancel', (e)=>e.preventDefault(), { passive: false });

canvas.addEventListener('mousedown', handleMouseDown);
window.addEventListener('mousemove', handleMouseMove);
window.addEventListener('mouseup', handleMouseUp);

// Animate
function draw() {
  const now = performance.now();
  const tSec = (now - startTime) / 1000;

  // Update wave ages
  updateWaves(tSec);

  // Uniforms
  gl.uniform2f(u_res, canvas.width, canvas.height);
  gl.uniform1f(u_time, tSec);
  gl.uniform3f(u_base, BASE_CYAN[0], BASE_CYAN[1], BASE_CYAN[2]);
  gl.uniform4fv(u_waves, waves);

  // Render
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

// Kickoff a gentle initial pulse in the center
setTimeout(() => {
  spawnWave(0.5, 0.5, 0.9);
}, 250);

// Prevent context menu on long-press
window.addEventListener('contextmenu', e => e.preventDefault());
</script>
</body>
</html>
