<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Alexander Ermolov</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEUAAP+KeNJXAAAADElEQVR4nGNgGNwAAACgAAGwBmIYAAAAAElFTkSuQmCC">
    <style>
        * { margin:0; padding:0; }
        html, body { height: 100%; }
        body {
            background-color: #000;
            font-family: 'Roboto Mono', monospace;
            font-size: 3vmax;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            overflow: hidden;
            touch-action: none;
        }
        p { width: 60%; margin:0; text-align: center; line-height: 1.7; }
        a { color:#fff; text-decoration:underline; transition: color 300ms; }
        a:hover { color: #fff; }
        
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
            z-index: 1;
        }
        
        p {
            position: relative;
            z-index: 2;
            pointer-events: none;
        }
        
        p a {
            pointer-events: auto;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <p>Alexander Ermolov</p>
    <p>
        <a href="https://github.com/htdt/">github</a>
        <a href="https://www.linkedin.com/in/alexander-ermolov/">linkedin</a>
    </p>
    <p><a href="mailto:alex@ermolov.space">alex@ermolov.space</a></p>

    <script>
      (function() {
        const MAX_WAVES = 16; // Number of simultaneous ripple sources in shader

        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl', { alpha: false, antialias: false, depth: false, stencil: false, preserveDrawingBuffer: false });
        if (!gl) {
          console.warn('WebGL not supported. Background effect disabled.');
          return;
        }

        // Vertex + Fragment Shaders (WebGL1 / GLSL ES 1.0)
        const vertSrc = `
          attribute vec2 a_pos;
          void main() {
            gl_Position = vec4(a_pos, 0.0, 1.0);
          }
        `;

        const fragSrc = `
          precision mediump float;

          uniform vec2 u_resolution;
          uniform float u_time;
          const int MAX_WAVES = ${MAX_WAVES};
          uniform vec2 u_wavePos[MAX_WAVES]; // in 0..1 (screen UV)
          uniform float u_waveTime[MAX_WAVES]; // seconds since start, negative when inactive

          // Hash/Noise helpers for organic feel
          float hash(vec2 p) {
            p = fract(p * vec2(123.34, 456.21));
            p += dot(p, p + 45.32);
            return fract(p.x * p.y);
          }

          float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
          }

          float fbm(vec2 p) {
            float v = 0.0;
            float amp = 0.5;
            mat2 m = mat2(1.6, 1.2, -1.2, 1.6);
            for (int i = 0; i < 5; i++) {
              v += amp * noise(p);
              p = m * p;
              amp *= 0.5;
            }
            return v;
          }

          vec3 palette(float t) {
            // Cosine palette across neon spectrum (blues, purples, greens, pinks, yellows)
            return 0.5 + 0.5 * cos(6.28318 * (vec3(0.00, 0.33, 0.67) + t));
          }

          void main() {
            vec2 res = u_resolution;
            float aspect = res.x / res.y;
            vec2 uv = gl_FragCoord.xy / res; // 0..1

            // Aspect-corrected space centered at 0, preserving distances
            vec2 p = uv * 2.0 - 1.0;
            p.x *= aspect;

            // Accumulate ripple displacement and chroma shift
            vec2 disp = vec2(0.0);
            float chroma = 0.0;
            float glow = 0.0;

            for (int i = 0; i < MAX_WAVES; i++) {
              float t0 = u_waveTime[i];
              if (t0 < 0.0) { continue; }
              float age = u_time - t0;
              if (age < 0.0) { continue; }

              vec2 wp = u_wavePos[i]; // 0..1
              vec2 w = wp * 2.0 - 1.0; // -1..1
              w.x *= aspect;

              vec2 d = p - w;
              float dist = length(d) + 1e-4;
              float ripple = sin(12.0 * dist - 3.5 * age);

              // Natural decay over time and distance
              float decay = exp(-1.8 * age) * exp(-2.5 * dist);
              float wv = ripple * decay;

              disp += normalize(d) * wv * 0.06; // displacement strength
              chroma += wv * 0.8;               // color shift influence
              glow += smoothstep(0.35, 0.0, dist - 0.02 * age) * decay;
            }

            vec2 q = p + disp;

            // Subtle evolving field for psychedelic base
            float n = fbm(q * 2.0 + u_time * 0.05);
            float t = n + 0.15 * chroma + u_time * 0.07;

            // Blend neon palette with bright cyan base
            vec3 neon = palette(t);
            vec3 cyan = vec3(0.0, 1.0, 1.0);
            vec3 col = mix(cyan, neon, 0.65);
            col *= (1.0 + 0.45 * glow);

            // Subtle grain for organic feel
            float grain = (hash(gl_FragCoord.xy + u_time) - 0.5) * 0.04;
            col += grain;

            // Gentle gamma tweak for punchy vibrance
            col = pow(max(col, 0.0), vec3(0.9));

            gl_FragColor = vec4(col, 1.0);
          }
        `;

        // Compile helpers
        function compile(type, src) {
          const sh = gl.createShader(type);
          gl.shaderSource(sh, src);
          gl.compileShader(sh);
          if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
            const info = gl.getShaderInfoLog(sh);
            gl.deleteShader(sh);
            throw new Error('Shader compile failed: ' + info);
          }
          return sh;
        }

        function createProgram(vsSrc, fsSrc) {
          const vs = compile(gl.VERTEX_SHADER, vsSrc);
          const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
          const prog = gl.createProgram();
          gl.attachShader(prog, vs);
          gl.attachShader(prog, fs);
          gl.linkProgram(prog);
          if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            const info = gl.getProgramInfoLog(prog);
            gl.deleteProgram(prog);
            throw new Error('Program link failed: ' + info);
          }
          gl.deleteShader(vs);
          gl.deleteShader(fs);
          return prog;
        }

        const program = createProgram(vertSrc, fragSrc);
        gl.useProgram(program);

        // Fullscreen quad (triangle strip)
        const quad = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1,
          ]),
          gl.STATIC_DRAW
        );

        const a_pos = gl.getAttribLocation(program, 'a_pos');
        gl.enableVertexAttribArray(a_pos);
        gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

        // Uniform locations
        const u_timeLoc = gl.getUniformLocation(program, 'u_time');
        const u_resLoc = gl.getUniformLocation(program, 'u_resolution');
        const u_wavePosLoc = gl.getUniformLocation(program, 'u_wavePos[0]');
        const u_waveTimeLoc = gl.getUniformLocation(program, 'u_waveTime[0]');

        // Wave data arrays
        const wavePos = new Float32Array(MAX_WAVES * 2);
        const waveTime = new Float32Array(MAX_WAVES);
        for (let i = 0; i < MAX_WAVES; i++) waveTime[i] = -10000;
        let waveWriteIdx = 0;

        // Time base
        const start = performance.now();
        function nowSec() { return (performance.now() - start) / 1000; }

        // Resize handling for crisp rendering
        function resize() {
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          const w = Math.floor(canvas.clientWidth * dpr);
          const h = Math.floor(canvas.clientHeight * dpr);
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w; canvas.height = h;
            gl.viewport(0, 0, w, h);
          }
        }
        // Ensure CSS size fills viewport
        function fit() {
          const vw = window.innerWidth;
          const vh = window.innerHeight;
          canvas.style.width = vw + 'px';
          canvas.style.height = vh + 'px';
          resize();
        }
        window.addEventListener('resize', fit, { passive: true });
        fit();

        // Helper: add a new wave pulse at pixel coordinates
        function addWaveAt(px, py) {
          const rect = canvas.getBoundingClientRect();
          let x = (px - rect.left) / rect.width;
          let y = (py - rect.top) / rect.height;
          y = 1.0 - y; // convert from top-left origin to bottom-left
          wavePos[waveWriteIdx * 2 + 0] = x;
          wavePos[waveWriteIdx * 2 + 1] = y;
          waveTime[waveWriteIdx] = nowSec();
          waveWriteIdx = (waveWriteIdx + 1) % MAX_WAVES;
        }

        // Gesture handling (Pointer Events with multi-touch support)
        const lastForId = new Map(); // pointerId -> {x,y,t}
        const DIST_THRESH = 8; // px between pulses
        const TIME_THRESH = 50; // ms between pulses

        function onPointerDown(e) {
          e.preventDefault();
          addWaveAt(e.clientX, e.clientY);
          lastForId.set(e.pointerId, { x: e.clientX, y: e.clientY, t: performance.now() });
        }
        function onPointerMove(e) {
          if (!(e.buttons & 1)) return; // only when pressed
          e.preventDefault();
          const last = lastForId.get(e.pointerId);
          const t = performance.now();
          if (!last) {
            lastForId.set(e.pointerId, { x: e.clientX, y: e.clientY, t });
            return;
          }
          const dx = e.clientX - last.x;
          const dy = e.clientY - last.y;
          const dist2 = dx*dx + dy*dy;
          if (dist2 >= DIST_THRESH * DIST_THRESH || (t - last.t) >= TIME_THRESH) {
            addWaveAt(e.clientX, e.clientY);
            last.x = e.clientX; last.y = e.clientY; last.t = t;
          }
        }
        function onPointerUp(e) {
          e.preventDefault();
          lastForId.delete(e.pointerId);
        }
        function onPointerCancel(e) {
          e.preventDefault();
          lastForId.delete(e.pointerId);
        }

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        window.addEventListener('pointermove', onPointerMove, { passive: false });
        window.addEventListener('pointerup', onPointerUp, { passive: false });
        window.addEventListener('pointercancel', onPointerCancel, { passive: false });

        // iOS Safari sometimes needs explicit touch events to prevent scroll
        function preventTouch(e) { e.preventDefault(); }
        canvas.addEventListener('touchstart', preventTouch, { passive: false });
        canvas.addEventListener('touchmove', preventTouch, { passive: false });
        canvas.addEventListener('touchend', preventTouch, { passive: false });

        // Render loop
        function frame() {
          const t = nowSec();
          resize();

          gl.useProgram(program);
          gl.uniform1f(u_timeLoc, t);
          gl.uniform2f(u_resLoc, canvas.width, canvas.height);
          gl.uniform2fv(u_wavePosLoc, wavePos);
          gl.uniform1fv(u_waveTimeLoc, waveTime);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      })();
    </script>
</body>
</html>
