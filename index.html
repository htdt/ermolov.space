<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alexander Ermolov</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEUAAP+KeNJXAAAADElEQVR4nGNgGNwAAACgAAGwBmIYAAAAAElFTkSuQmCC">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Roboto Mono', monospace;
            font-size: 3vmax;
            color: #fff;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }

        .overlay p {
            margin: 0;
            line-height: 1.7;
        }

        .overlay a {
            color: #fff;
            text-decoration: underline;
            transition: color 300ms;
            pointer-events: auto;
        }

        .overlay a:hover {
            color: #4a9eff;
        }

        @media (max-width: 600px) {
            body {
                font-size: 4vmax;
            }
            .overlay {
                top: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="overlay">
        <p>Alexander Ermolov</p>
        <p>
            <a href="https://github.com/htdt/">github</a>
            <a href="https://www.linkedin.com/in/alexander-ermolov/">linkedin</a>
        </p>
        <p><a href="mailto:alex@ermolov.space">alex@ermolov.space</a></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Vertex shader
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // Fragment shader with Mandelbulb raymarching
        const fragmentShader = `
            uniform vec2 resolution;
            uniform float time;
            uniform vec3 cameraPos;
            uniform vec3 cameraTarget;
            uniform float power;
            uniform int iterations;
            uniform int maxSteps;
            varying vec2 vUv;

            const float EPSILON = 0.001;
            const float MAX_DIST = 20.0;

            // Mandelbulb distance estimator - returns distance and iteration count
            vec2 mandelbulb(vec3 pos) {
                vec3 z = pos;
                float dr = 1.0;
                float r = 0.0;
                float iterCount = 0.0;

                for(int i = 0; i < 12; i++) {
                    if(i >= iterations) break;

                    r = length(z);
                    if(r > 2.0) break;
                    iterCount = float(i);

                    // Convert to polar coordinates
                    float theta = acos(z.z / r);
                    float phi = atan(z.y, z.x);
                    dr = pow(r, power - 1.0) * power * dr + 1.0;

                    // Scale and rotate the point
                    float zr = pow(r, power);
                    theta = theta * power;
                    phi = phi * power;

                    // Convert back to cartesian coordinates
                    z = zr * vec3(
                        sin(theta) * cos(phi),
                        sin(phi) * sin(theta),
                        cos(theta)
                    );
                    z += pos;
                }

                float dist = 0.5 * log(r) * r / dr;
                return vec2(dist, iterCount / float(iterations));
            }

            // Scene distance
            float scene(vec3 p) {
                return mandelbulb(p).x;
            }

            // Calculate normal
            vec3 getNormal(vec3 p) {
                vec2 e = vec2(EPSILON, 0.0);
                return normalize(vec3(
                    scene(p + e.xyy) - scene(p - e.xyy),
                    scene(p + e.yxy) - scene(p - e.yxy),
                    scene(p + e.yyx) - scene(p - e.yyx)
                ));
            }

            // Raymarching - returns (distance, iteration_ratio)
            vec3 raymarch(vec3 ro, vec3 rd) {
                float t = 0.0;
                for(int i = 0; i < 80; i++) {
                    if(i >= maxSteps) break;

                    vec3 p = ro + rd * t;
                    vec2 m = mandelbulb(p);

                    if(m.x < EPSILON) return vec3(t, m.y, 1.0);
                    if(t > MAX_DIST) break;

                    t += m.x * 0.6;
                }
                return vec3(-1.0, 0.0, 0.0);
            }

            // Ambient occlusion
            float ao(vec3 p, vec3 n) {
                float occ = 0.0;
                float sca = 1.0;
                for(int i = 0; i < 5; i++) {
                    float h = 0.001 + 0.15 * float(i) / 4.0;
                    float d = scene(p + h * n);
                    occ += (h - d) * sca;
                    sca *= 0.95;
                }
                return clamp(1.0 - 1.5 * occ, 0.0, 1.0);
            }

            // Color palette - vibrant Mandelbrot-style
            vec3 palette(float t) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.0, 0.1, 0.2);
                return a + b * cos(6.28318 * (c * t + d));
            }

            void main() {
                // Screen coordinates - fixed diagonal FOV for consistent sizing
                vec2 uv = (vUv - 0.5) * 2.0;
                float aspect = resolution.x / resolution.y;
                // Scale to maintain consistent apparent size regardless of orientation
                float scale = sqrt(aspect * aspect + 1.0) / sqrt(2.0);
                uv.x *= aspect;
                uv *= scale;

                // Camera setup
                vec3 forward = normalize(cameraTarget - cameraPos);
                vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
                vec3 up = cross(forward, right);

                // Ray direction
                vec3 rd = normalize(forward + uv.x * right + uv.y * up);
                vec3 ro = cameraPos;

                // Raymarch
                vec3 result = raymarch(ro, rd);
                float t = result.x;
                float iterRatio = result.y;

                vec3 color = vec3(0.0);

                if(t > 0.0) {
                    vec3 p = ro + rd * t;
                    vec3 n = getNormal(p);

                    // Lighting
                    vec3 lightPos = cameraPos + vec3(2.0, 3.0, -1.0);
                    vec3 lightDir = normalize(lightPos - p);

                    float diff = max(dot(n, lightDir), 0.0);
                    float spec = pow(max(dot(reflect(-lightDir, n), -rd), 0.0), 32.0);
                    float ambient = 0.3;
                    float occ = ao(p, n);

                    // Color based on iteration count (Mandelbrot-style)
                    vec3 baseColor = palette(iterRatio * 3.0 + time * 0.05);
                    // Add variation based on position
                    baseColor = mix(baseColor, palette(length(p) * 0.5), 0.3);

                    color = baseColor * (ambient + diff * 0.7) * occ;
                    color += vec3(1.0, 0.9, 0.8) * spec * 0.5;

                    // Fog
                    float fog = 1.0 - exp(-t * 0.1);
                    color = mix(color, vec3(0.02, 0.02, 0.05), fog);
                } else {
                    // Background gradient
                    color = mix(vec3(0.02, 0.02, 0.05), vec3(0.1, 0.05, 0.15), uv.y * 0.5 + 0.5);
                }

                // Tone mapping and gamma correction
                color = color / (color + vec3(1.0));
                color = pow(color, vec3(0.4545));

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Setup
        let scene, camera, renderer, material;
        let mouseDown = false;
        let lastMouseX = 0, lastMouseY = 0;
        let cameraDistance = 3.0;
        // Base angles (manual rotation)
        let manualAngleX = 0.3;
        let manualAngleY = 0;
        // Auto rotation
        let autoAngleY = 0;
        // Gyro
        let gyroEnabled = false;
        let gyroBeta = 0, gyroGamma = 0;

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 1;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // Shader material
            material = new THREE.ShaderMaterial({
                uniforms: {
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    time: { value: 0 },
                    cameraPos: { value: new THREE.Vector3() },
                    cameraTarget: { value: new THREE.Vector3(0, 0, 0) },
                    power: { value: 8.0 },
                    iterations: { value: 10 },
                    maxSteps: { value: 60 }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader
            });

            // Fullscreen quad
            const geometry = new THREE.PlaneGeometry(2, 2);
            const quad = new THREE.Mesh(geometry, material);
            scene.add(quad);

            // Controls
            setupEventListeners();

            // Animation loop
            animate();
        }

        function setupEventListeners() {
            // Mouse events
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (mouseDown) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;

                    manualAngleY += deltaX * 0.005;
                    manualAngleX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, manualAngleX + deltaY * 0.005));

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
                // Continue auto-rotation from current angle
            });

            renderer.domElement.addEventListener('mouseleave', () => {
                mouseDown = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance = Math.max(1.5, Math.min(8.0, cameraDistance + e.deltaY * 0.005));
            });

            // Touch events
            let touchStartDistance = 0;

            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    mouseDown = true;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();

                if (e.touches.length === 1 && mouseDown) {
                    const deltaX = e.touches[0].clientX - lastMouseX;
                    const deltaY = e.touches[0].clientY - lastMouseY;

                    manualAngleY += deltaX * 0.008;
                    manualAngleX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, manualAngleX + deltaY * 0.008));

                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (touchStartDistance > 0) {
                        const scale = touchStartDistance / distance;
                        cameraDistance = Math.max(1.5, Math.min(8.0, cameraDistance * scale));
                        touchStartDistance = distance;
                    }
                }
            });

            renderer.domElement.addEventListener('touchend', () => {
                mouseDown = false;
                touchStartDistance = 0;
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            });

            // Gyroscope for mobile
            if (window.DeviceOrientationEvent) {
                // Request permission on iOS 13+
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    renderer.domElement.addEventListener('touchstart', function requestGyro() {
                        DeviceOrientationEvent.requestPermission()
                            .then(response => {
                                if (response === 'granted') {
                                    enableGyro();
                                }
                            });
                        renderer.domElement.removeEventListener('touchstart', requestGyro);
                    }, { once: true });
                } else {
                    enableGyro();
                }
            }

            function enableGyro() {
                window.addEventListener('deviceorientation', (e) => {
                    if (e.alpha !== null) {
                        gyroEnabled = true;
                        gyroAlpha = e.alpha;
                        gyroBeta = e.beta;
                        gyroGamma = e.gamma;
                    }
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            let camX, camY, camZ;

            // Auto-rotate (always runs)
            autoAngleY += 0.0008;

            // Gyro offsets
            let gyroOffsetX = 0;
            let gyroOffsetY = 0;
            if (gyroEnabled) {
                const beta = (gyroBeta - 45) * Math.PI / 180;
                const gamma = gyroGamma * Math.PI / 180;
                gyroOffsetX = Math.max(-0.5, Math.min(0.5, -beta * 0.5));
                gyroOffsetY = gamma * 0.5;
            }

            // Sum all offsets
            let finalAngleX = manualAngleX + gyroOffsetX;
            let finalAngleY = manualAngleY + autoAngleY + gyroOffsetY;

            // Clamp vertical angle
            finalAngleX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, finalAngleX));

            // Update camera position
            camX = Math.cos(finalAngleY) * Math.cos(finalAngleX) * cameraDistance;
            camY = Math.sin(finalAngleX) * cameraDistance;
            camZ = Math.sin(finalAngleY) * Math.cos(finalAngleX) * cameraDistance;

            material.uniforms.cameraPos.value.set(camX, camY, camZ);
            material.uniforms.time.value += 0.01;

            // Animate the fractal structure
            material.uniforms.power.value = 8.0 + Math.sin(material.uniforms.time.value * 0.3) * 0.5;

            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
